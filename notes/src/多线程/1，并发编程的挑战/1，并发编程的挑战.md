并发编程的挑战

1. 上下文切换

   CPU通过给每个线程分配CPU时间片来实现多线程，通过不停的切换线程执行，让我们感觉多个线程是同时执行的，CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换 到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下人切换

   当执行时处理的数据量比较小的时候，因为上下文的切换，并发不一定会比串行快

2. 如何减少上下文切换

   - 无锁并发编程，多进程竞争锁的时候，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁，如将数据按照某个指标分开，不同的线程处理不同的分段
   - CAS算法，可以使用CAS 算法来更新数据，而不需要加锁
   - 使用最少线程，避免创建不必要的线程，如果创建了大量不需要的线程会使很多线程处于等待状态
   - 协程，在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

3. 死锁

   两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去

4. 避免死锁

   - 避免一个线程同时获取多个锁
   - 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
   - 尝试使用定时锁，使用lock.tryLock(timeout) 来替代使用内部锁机制
   - 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

