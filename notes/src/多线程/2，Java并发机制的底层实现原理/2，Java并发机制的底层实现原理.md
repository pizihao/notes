Java 并发机制的底层实现原理

> volatile

1. volatile 保证了共享变量的"可见性"，当一个线程修改一个共享变量时，另一个线程能读到这个修改的值，volatile关键字并不会引起线程上下文切换和调度

2. 定义

   Java 编程语言允许线程访问共享变 量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个 变量。Java 语言提供了 volatile，在某些情况下比锁要更加方便。如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。

3.  原理：有volatile变量修饰的共享变量进行写操作的时候会多出一些汇编代码，其语义为：

   - 将当前处理器缓存行的数据写回到系统内存
   - 这个写回内存的操作会使其他CPU里缓存了该地址的数据无效
   - 在系统中，如果对声明了volatile的变量进行了写操作，jvm就会向处理器发送一条Lock前缀的指令，将这个变量所缓存的行数据写会到系统内存
   - 多处理器下，每个处理器都会不断查探总线上传播的数据，当发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，然后重新从系统内存中把数据读到处理器缓存中

> synchronized

1. synchronized实现同步的基础：java中的每个对象都可以作为锁

   - 对于普通同步方法，锁的是当前实例对象
   - 对于静态同步方法，锁的是当前类的Class对象
   - 对于同步方法块，锁是synchronized括号里配置的对象

2. 当一个线程试图访问同步代码块时，他首先必须得到锁，退出或抛出异常时必须释放锁

3. 代码块的同步是使用monitorenter和monitorexit指令实现的，方法同步也可以使用这两个指令来实现

   monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit是插入到方法结束处和异常处，

4. java对象头 synchronized用的锁是存在java对象头里的。

   ![img](https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
   
5. 锁的升级和对比

   java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。

   - 偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总会由统一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录中存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需测试一下对象头的Mark word里是否存储着执行当前线程的偏向锁，如果测试成功，则表示线程已经获取了锁，如果失败，判断Mark word中偏向锁的标识是否设置成了1 ，如果没有则用CAS竞争锁，如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程

     偏向锁的撤销：当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，在全局安全点，在这个时间点上没有正在执行的字节码，先暂停拥有偏向锁的线程，然后检查持有偏向锁的 线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，那么就遍历偏向对象的锁记录，如果能找到对应的偏向对象，说明偏向所有者正持有锁，升级为轻量级锁，偏向锁被撤销

     偏向锁没有解锁的过程，所以当偏向锁被撤销的时候会出现两种情况
   
     - 不可偏向的无锁状态：原来已经获取了偏向锁的线程执行完成，对象处于闲置状态，相当于原来的偏向锁已经过期无效了
     - 不可偏向的已锁状态：原来已经获取了偏向锁的线程可能还没有执行完，之前的偏向锁依然是有效的，这个时候偏向锁膨胀为轻量级锁
   
   - 轻量级锁加锁：线程在执行同步块之前，jvm会在当前线程的栈帧中创建用于存储锁记录的空间，之后将对象头中的Mark word复制到锁记录中，之后线程尝试使用CAS将对象头中的Mark word替换为指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示其他线程正在竞争这个锁，当前线程就会使用自旋来获取锁，如果在自旋一定次数之后还是没有获取到锁，这个锁就会膨胀为重量级锁
   
     轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作将 复制到当前栈帧中的对象头Mark word信息替换回对象头，如果成功，则表示没有竞争发生，程序正常进行，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
   
     因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级成了重量级锁，就不会再回到轻量级锁状态，当锁处于这个状态下，其他线程视图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后就会把这些阻塞的线程唤醒，被唤醒的线程就会进行锁的争夺
   
   - ![img](https://img-blog.csdn.net/20170626122144783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV4aWxl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

>原子操作的实现原理

1. 原子操作：不可被中断的一个或一系列操作。
2. 相关术语：
   - 缓存行 Cache line 缓存的最小操作单位
   - 比较并交换 Compare and Swap CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换
   - CPU流水线 CPU pipeline  
   - 内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线
3. 处理器保证从系统内存中读 取或者写入一个字节是原子的，意思是当一个处理器读取或是写入一个字节时，其他处理器不能 访问这个字节的内存地址。
4. 处理器提供总线锁定 和缓存锁定两个机制来保证复杂内存操作的原子性。

> java如何实现原子操作

1. 使用循环CAS实现原子操作，自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，CAS也会出现一些问题：

   - ABA问题，其解决思路就是使用版本号，在变量前面追加版本号，每次更新的时候把版本号加一
   - 循环时间长开销大，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销
   - 只能保证一个共享变量的原子操作，可以把多个变量放入一个对象中进行CAS操作

2. 使用锁来进行原子操作

   锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。是除了偏向锁，JVM 实现锁的方式 都用了循环 CAS，即当一个线程想进入同步块的时候使用循环 CAS 的方式来获取锁， 当它退出同步块的时候使用循环 CAS 释放锁。

   

   

   