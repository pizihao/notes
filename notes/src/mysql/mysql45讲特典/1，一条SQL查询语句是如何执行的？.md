# 一条SQL查询语句是如何执行的？

先来看一个简单的SQL语句

~~~sql
select * from T where ID=10；
~~~

这是一个简单的查询语句，只需要运行就可以快速的查询出对应的数据

现在探索一下在数据库内核中的执行过程

> mysql可以分为Server层和存储引擎层

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。
- 连接器：用来和客户端建立连接，获取权限，维持和管理连接，当获取这个权限后，连接会依据当前读到的权限信息进行后续的处理，即使此时管理员修改了该用户的权限，也不会对这次连接产生影响。连接分为长连接和短连接
  - 短连接：SQL查询几次后就会断开，再次查询需要重新建立连接 成本比较高
  - 长连接：会长时间占用内存，易产生OOM，导致Mysql异常重启
  - 对长连接产生OOM的解决方案
    1. 定期断开长连接
    2. 在mysql5.7以后可以在每次执行完一个比较大的操作之后通过执行mysql_reset_conection来重新初始化连接资源，这个过程不需要重连和重新做权限验证，只是会将连接恢复 到刚刚创建完时的状态
- 查询缓存：对于每一个查询的SQL语句，在查询数据库存储文件之前，都会先去查看是否命中缓存，如果命中缓存那么直接返回缓存中的值，不命中则去查询数据库，如果数据库中的数据发生了更新，那么这个表对应的缓存就会失效，对于更新操作比较频繁的表来说，查询的命中效率会非常低，反而会降低数据库的性能，所以在mysql8.0以后直接删除了这部分的功能
- 分析器：分析器主要是分析出这条SQL语句是要干什么。我们写SQL的第一个就是标明这条SQL要干什么。比如select是查询，insert是插入，update是修改更新，delete是删除，create是创建等等。除了这些分析器还会分析出这条查询语句的查询条件是什么。这里就要保证这条SQL的语法是正确的，分析器可以识别的。
- 优化器：优化器是mysql用来对程序员写的SQL语句在真正执行之前的最后一步优化，其中包括：选择的是哪个索引，是否要使用索引？还有多表查询的联合顺序等。每一种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。
- 执行器：执行器就是负责执行SQL语句的部分，词法分析和语法分析
  - 首先他要查询验证一下权限，查询当前用户是否有权限去执行，比如有的用户对数据库数据只读，那么他就无法执行更新操作。如果用户没有权限，就返回权限不足的提示或者错误。
  - 如果SQL语句走了另一条路，命中了缓存，那么就会在查询缓存返回结果的时候做权限验证。
  - 有权限的话，就去打开需要的表继续执行sql语句，打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
  - 比如使用了索引，就去查索引拿出索引值，取出数据存到结果集中，并在查询结束后返回给客户端。
- 这条SQL语句就执行完成了。
- InnoDB的存储引擎，它是当前mysql默认的存储引擎，也是互联网等公司数据库存储引擎的不二选择
- 关于InnoDBd的特性：
  - 支持数据库事务，在可重复读的隔离级别下，通过MVCC解决了不可重复读的问题，通过间隙锁的引入解决了幻读的问题
  - 支持行级锁和表级锁，默认是行级锁，更小的颗粒度意味着更高的并发度
  - 支持外键
  - 为处理巨大数据量的最大性能设计，它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的
  - InoDB中不保存表的行数，清空表的时候它是一个一个的删除，效率很慢
  - InnDB使用B+树来做索引，查询效率高，支持索引上的范围查询
- 其他存储引擎不再说
- 有关InnoDB的其他特点
  - InnoDB表的数据总是有序存放的
  - 当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值
  - 数据位置发生改变的时候，InnoDB只需要修改主键索引
  - InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查找的时候需要走两次索引查找
  - InnoDB支持变长数据类型， 不同记录的长度可能不同

