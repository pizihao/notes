# 给表加个字段怎么有这么多阻碍？

**有关锁的部分**

- 根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类

- 当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构

- Flush tables with read lock (FTWRL) 全局锁

- 全局锁是对整个数据库实例加锁，甚至有的时候是对数据库服务器加锁，他会使整个数据库完全处于只读状态，一般是用在做全库逻辑备份的时候加全局锁

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停止；如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

- 如果进行备份的时候不加锁的话，那么使用备份进行恢复数据就有可能出现数据不一致的情况

- 备份如果发生在更新操作之前,那么如果使用备份数据恢复的话,更新操作就丢了

- 在重复读之下，进行整个事务的过程中，整个事务所能看到的视图是不变的，在这个过程中，无论数据库中是否有新的事务提交，对于这个事务来说，是没有关系的，使用这个事务拿到一致性视图，这个时候就可以进行正常的备份操作而不需要加全局锁了

- 但是并不是所有的数据库引擎都支持可重复读这个隔离级别

- 表锁和元数据锁

- 表锁的语法是 lock tables … read/write 可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放

- 加上读锁，不会限制别的线程读，但会限制别的线程写。加上写锁，会限制别的线程读写。

- 另一类表级的锁是 MDL（metadata lock)元数据锁。MDL 不需要显式使用，在访问一个表的时候会被自动加上

- 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查

- 读写锁之间，写锁之间是互斥的，用来保证变表结构操作的安全性，因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

  
