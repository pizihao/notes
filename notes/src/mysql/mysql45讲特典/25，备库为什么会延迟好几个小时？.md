备库为什么会延迟好几个小时？

> 备库并行复制能力。

- 备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟
- 多线程复制机制：吧sql_thread,拆成多个线程
- sql_thread演变 为coordinator，不再直接更新数据只负责读取中转日志和分发事务。真正更新日志的，变成了 worker 线程。work 线程的个数，slave_parallel_workers 决定work线程的个数
- 事务不能按照轮询的方式分发给各个worker，因为，事务被分发给 worker 以后，不同的 worker 就独立执行了。但是，由于 CPU 的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。
- 同一个事务的多个更新语句，不能分给不同的 worker 来执行，有可能看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。
- coordinator 在分发的时候，需要满足以下这两个基本要求：
  - 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。
  - 同一个事务不能被拆开，必须放到同一个 worker 中。
- 按表分发策略
  - 按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。
  - 如果有跨表的事务，还是要把两张表放在一起考虑的。
  - 每个worker线程对应一个hash表，用于保存当前这个在这个worker的执行队列里的事务所涉及的表，hash表的可以是"库名.表名"，value是一个数字，表示队列中有多少个事务修改过这个表
  - 在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。
  - 每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：
    - 如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;
    - 如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；
    - 如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。
- 按行分发策略
  - 按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。
  - 这时要判断一个事务和worker是否冲突，用的规则就是判断事务和worker中hash表中事务修改的是否是同一行
  - 这时候的 key，就必须是“库名 + 表名 + 唯一键的值”
  - 这个唯一键还需要注重考虑
  - 相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。
- 两个分发策略的约束条件
  - 要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；
  - 表必须有主键；
  - 不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。
- 按行分发存在的问题：
  - 耗费内存，需要吧要处理的行都记录下来
  - 耗费CPU资源，需要解析binlog，计算hash值，成本很高
  - 所以实现这个策略会设置一个阈值，单个事务如果超过设置的行数阈值，就暂时退化为单线程模式。
- MySQL 5.6 版本的并行复制策略：按库并行，用于决定分发策略的hash表里，key就是数据库名
- MariaDB 的并行复制策略：
  - 能够在同一组里提交的事务，一定不会修改同一行；
  - 主库上可以并行执行的事务，备库上也一定是可以并行执行的。
  - 一组提交的事务有一个相同的commit_id，commit_id相同的事务是可以并行的
- MySQL 5.7 的并行复制策略：思路
  - 同时处于 prepare 状态的事务，在备库执行时是可以并行的；
  - 处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。
- MySQL 5.7.22 的并行复制策略：基于 WRITESET 的并行复制。
  - WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。
  - 

