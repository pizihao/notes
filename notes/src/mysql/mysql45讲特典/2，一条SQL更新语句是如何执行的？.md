### 一条SQL更新语句是如何执行的？

- 执行一条SQL语句依然要通过数据库的Server层。
- 最开始是连接器，我们执行语句之前需要进行连接，这个可以是通过命令行，也可以是通过数据库连接工具或者程序连接，比如Navicat。连接器就会通过这些信息，建立连接，验证权限。
- 然后就是分析器，分析器分析出了这是一条更新语句。
- 优化器对这条SQL进行优化，如要不要使用索引等。
- 最后执行器就要执行这条SQL，执行之前要有一次权限验证
- 更新语句中存在两个重要的日志模块，redo log 重做日志 和 binlog 归档日志

> 重做日志 redo log

- 当mysql中更新操作比较多的时候，如果每次的更新操作都需要写一遍磁盘，然后从找到对应的那条记录，再更新。这个过程的I/O成本和查找成本都很高，为了解决这个问题，mysql使用了WAL技术来提高更新效率，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
- 具体说，当一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候就算更新操作完成了
- 当mysql把数据写入了redo log 还没有写入磁盘的时候，这时候的数据被称为脏数据，这些脏数据存放在缓冲池中，查询的时候可以直接从缓冲池中取得数据，保证了数据的一致性
- 同时写到redo log中的记录会在比较空闲或者redo log写满的时候把其中的操作刷新到磁盘
- 重做日志被设计成可循环使用，当日志文件写满时，重做日志中对应数据已经被刷新到磁盘的那部分不再需要的日志可以被覆盖重用
- InnoDB把记录写到redo log中的过程也是一个写磁盘的过程，不过更新的过程是在磁盘上随机IO,而redo log 在磁盘上是顺序写入，效率要高
- write pos是当前记录的位置，一边写一边后移，写到最后一个文件的末尾就会回到初始文件的开头，checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件
- 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这就是 crash-safe

> binlog

- redolog是InnoDB特有的日志文件，Server层也有自己的日志，被称为binlog
- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

> 两阶段提交

- 为了使两份日志之间的逻辑保持一致，采取了两阶段提交
- 在更新操作记录到redo log里面时 redo log会处于prepare状态，并不执行事务提交，等执行器生成这个操作的binlog，并将binlog写入磁盘之后，执行器才会调用引擎的提交事务接口，引擎把刚才的redo log改成提交状态，更新才算完成