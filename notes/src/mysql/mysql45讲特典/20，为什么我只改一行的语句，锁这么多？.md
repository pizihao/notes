为什么我只改一行的语句，锁这么多？

> 原则 1：加锁的基本单位是 next-key lock(间隙锁和行锁)。next-key lock 是前开后闭区间。
>
> 原则 2：查找过程中访问到的对象才会加锁。
>
> 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
>
> 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
>
> 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

- 在删除数据的时候尽量加 limit
- 可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。

相关测试:

现在建立一个表

~~~sql
CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;
~~~

插入几个字段：

~~~sql
insert into t values(0,0,0),(4,4,4,),(10,10,10),(15,15,15),(21,21,21),(25,25,25);
~~~

查看间隙锁的生成

#### 一，

- 开启一个事务，执行一个修改语句：`update evayinfo_test_cs set d = d + 1 where id = 6` 
- 首先，id=6并不存在，所以这里会有间隙锁生成
- 那么间隙锁的范围是什么？
- 为了方便，查看一下事务的锁等待超时时间`SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';`
- 通过结果可以看到是50秒。可以通过`SET innodb_lock_wait_timeout=600;`将其修改为十分钟
- 现在分析到底锁了那些字段
  - 再修改之前，会先查询到6这个id，但是没有
  - 所以会向前查询，直到查询到前一个确实存在的记录  id = 4，停止 
  - 同时向后查询，查询到一条确实存在的记录 id = 10
  - 间隙锁是前开后闭的所以这一段锁是 (4,10]，10不符合条件 所以这一段锁为 (4,10)
  - 可以看到4不会上锁，修改id= 4 `Affected rows: 1`,修改成功
  - 可以看到5上了锁，添加 id= 5 阻塞
  - 如果修改id=5呢，这里是不阻塞的，修改id=5的时候，会加间隙锁(5,10),间隙锁之间不冲突
  - 测试10，`Affected rows: 1` 修改成功了

#### 二，

- 表中的c是普通索引，现在执行select id from evayinfo_test_cs where c = 4 lock in share mode 
- 分析
  - 这里会在c=4这个位置向前查询 锁住(0,4]
  - 其次这里是普通索引，mysql会认为c=4可能并不是一个，所以还会通过4向后查，一直到c=10才停止，因为4~10中间不存在值 会锁住(4,10]，最后查询到的值10不符合查询条件，会退化成间隙锁
  - 最后锁上的范围是(0,10)；
  - 可以看到c=6 被上了锁，`insert into evayinfo_test_cs  VALUES (6,6,6)`, 阻塞
  - 可以看到c=3上了锁 `insert into evayinfo_test_cs  VALUES (6,6,6)` 阻塞
  - 如果我们修改id=4呢？不阻塞
  - 修改c=4 呢？阻塞