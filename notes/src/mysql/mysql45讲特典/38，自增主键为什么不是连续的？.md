# 自增主键为什么不是连续的？

- 自增主键
  - 自增主键可以让主键索引尽量的保持递增顺序插入，避免了页分裂，因此索引更紧凑
  - 自增主键不能保证连续的递增
  - 表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。
- 不同的数据引擎保存自增主键的方式不同
  - MyISAM 引擎的自增值保存在数据文件中。 
  - InnoDB保存在内存中，数据库重启时可能会归零，在没有MYSQL8.0之后，会将自增的值存放在redo log中，重启的时候依靠redolog恢复重启之前的值
- 在mysql中AUTO_INCREMENT保存的是自增后的值
- 自增值的修改机制
  - 主键自增是将 主键字段定义为 AUTO_INCREMNT，这样在插入一行数据的时候
  - 如果插入数据时的id指定为0，null或未指定值，那么就把这个表当前的AUTO_INCREMNT值填到自增字段
  - 如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值
- 如果某次要插入的值小于当前的自增值 这个表的自增值不变
- 如果大于等于自增值，就把当前自增值修改为新的自增值
- auto_increment_offset 自增的初始值 auto_increment_increment自增步长
- 每次自增值修改时就需要在auto_increment_offset 开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于当前要插入的值的一个值，作为新的自增值
- 自增值的修改时机
- 当添加一条记录时，没有添加主键，说明需要使用自增值，但是该表中还存在另一个唯一索引，在插入的时候，系统的自增值进行的修改，比原来自增了步长，之后添加的时候碰到唯一索引冲突报错，记录没有插入，但是自增值没有修改会原来的值，这样在下一次添加的时候就会出现自增值不连续的情况
- 唯一键冲突是导致自增主键 id 不连续的一种原因。
- 除此之外还有事务回滚
- 对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：
  - 语句执行过程中，第一次申请自增 id，会分配 1 个；
  - 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；
  - 2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；
  - 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。
  - 这个时候往往造成最后一次申请的id用不完，也就造成了不连续的情况

