普通索引和唯一索引，应该怎么选择？

- 如果确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候，就应该用关键字UNIQUE把它定义为一个唯一索引，Mysql会在有新纪录插入数据表时，自动检查新纪录的这个字段的值是否已经在某个记录的这个字段里出现过了。如果是，mysql将拒绝插入那条新纪录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复
- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
- 非主键索引会存储主键索引的值，因此推荐选用短字段当主键索引
- InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB
- change buffer 写缓冲 数据在内存中直接更新，不在内存的话change buffer记录更新操作，然后定时刷新到磁盘或者读取数据的时候更新读入内存的数据并刷新
- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
-  change buffer 记录的是更新这个动作，操作而不是数据，写change buffer 时也会写redo log，change buffer也会被写到磁盘上
- 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge：
  1. 访问数据页，将change buffer和buffer pool中的数据合并 
  2. 定期merge 
  3. 在数据库正常关闭（shutdown）的过程中
- 唯一索引是用不到change buffer的，因为使用唯一索引进行添加的时候，需要判断是否违反了唯一性，所以必须要把数据页拿到内存中，这个时候change buffer就没有必要使用了
- 只有普通索引可以使用 change buffer
- 将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，明显提高了性能
- 对于写远多于读的表更适合change buffer
- 修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。
- 内存中存放着最新数据，只要查询时在内存命中，此时就直接返回内存的数据即可。如果没有在内存命中，此时要去磁盘中找，磁盘中的数据可能是旧版本，读入内存后要执行change_buffer来保证数据最新有效，注意到change_buffer并没有修改磁盘数据而是内存数据。磁盘数据的修改是通过redo_log实现最终落盘的。
- redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
- 系统表空间就是用来放系统信息的，比如数据字典什么的，对应的磁盘文件是ibdata1,
  数据表空间就是一个个的表数据文件，对应的磁盘文件就是 表名.ibd
- 为了解决数据Page和Undo Log膨胀的问题，需要引入purge机制进行回收
- changebuffer跟普通数据页一样也是存在磁盘里，区别在于changebuffer是在共享表空间ibdata1里
- redolog有两种，一种记录普通数据页的改动，一种记录changebuffer的改动
- 只要内存里脏页（innodb buffer pool）里的数据发生了变化，就一定会记录2中前一种redolog（对数据的修改记录在changebuffer里的时候，内存里是没有这个物理页的，不存在脏页）
- 真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的，而不是根据redolog
- merge 的执行流程是这样的：
  - 从磁盘读入数据页到内存（老版本的数据页）；
  - 从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；
  - 写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。
- 到这里 merge 过程就结束了。这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。

