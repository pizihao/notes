# count(*)这么慢，我该怎么办？

- 不同的存储引擎 count(*)实现的方式是不同的
  - MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\*) 的时候会直接返回这个数，效率很高；
  - 而 InnoDB 执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
- InnoDB是索引组织表，主键索引树的叶子结点的是数据，而普通索引树的叶子结点是主键值，所以普通索引树比主键索引树小很多
- 对于count(*)这个操作，MYsql优化器会自动选择最小的那颗索引树来遍历，因为结果是一样的
- 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。
- 如果想要加快速度，可以用缓存系统保存计数，但是有可能出现丢失更新的问题，而且这值在逻辑上还可能是不准确的
- 还可以在数据库保存计数，把这个计数直接放到数据库里单独的一张计数表中，不会丢失更新也可是通过事务解决数据不准确的问题
- count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。
- count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。
- 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
- 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- 对于 count(字段) 来说：
  - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
- 但是 count(\*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

