事务到底是隔离的还是不隔离的？

- 可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。
- 也就是说，一个在可重复读隔离级别下执行的事务是不受其他影响的
- 一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，就会进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？
- begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动，start transaction with consistent snapshot 这个命令会直接启动一个事务，创建出一致性视图

> “快照”在 MVCC 里是怎么工作的？

- 在启动一个事务的时候，如果处于可重复读的隔离级别下，这个事务就创建一个一致性视图，也可以称作是快照，这个快照是基于整个库的。

- 这个快照的实现： 每个事务都有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的，所以先启动的事务的事务id总是小于后启动的事务id

- 每一行的数据在数据库中都是有多个版本的，每次更新数据的事务都会生成对应的数据版本 ，版本中包含本次数据的值,事务id,还有一个引用(指向上一个数据版本)，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id

- 数据库中的每一行记录，都可能有多个版本(row)，每个版本都有自己的 row trx_id

- 这里的每个版本并不是真实存在在数据文件中的，而是每次需要的时候通过undolog计算出来的，每次版本更新都会写一个undolog。这个undolog只记录当前版本回到上一个版本的操作

- 事务执行之后，其他事务的更新对它虽然不可见，但是数据版本还是可见的，因为数据库实际上存储的是最新版本的数据。但是对于该事务来说，需要根据版本号以及Undo Logs计算出他需要的版本对应的数据

- InnoDB为每个事务构造了一个数组，来保存这个事务启动的瞬间当前正在活跃也就是还没有提交的事务的事务id，==数组里面==事务 ID 的最小值记为低水位，==当前系统里面==已经创建过的事务 ID 的最大值加 1 记为高水位，这个数组和高水位就是readview ，。

- 对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有几种情况

  - 如果这个row trx_id  < 低水位 表示这个事务已经提交 可见
  - 如果row trx_id > 高水位 表示这个事务还没有开始 不可见
  - 如果 低水位 < row trx_id <高水位 则还有两种情况
    - 如果row trx_id在数组中，说明还没有提交 不可见
    - 如果row trx_id不在数组中，说明这个事务虽然创建的晚但是commit的早 可见

- 所以这个快照就是可以简单的认为是当前一致性视图的低水位位置的数据库信息，即使已经发生了更改也会通过undolog和事务id，row trx_id是否在数组中去计算当前可见的数据信息

- 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。除了 update 语句外，select 语句如果加锁，也是当前读。

- 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

- 事务启动的时候还要保存“现在正在执行的所有事物ID列表”，如果一个row trx_id在这列表中，也要不可见。这个列表中的row trx_id的最小值可能比低水位还要小

  

