# 都说InnoDB好，那还要不要使用Memory引擎？

- InnoDB和Memory存储引擎的主键索引的组织方式是不同的
  - InnoDB表的数据就放在主键索引上，主键索引是B+树，其中的属于都是有序存放的。
    - 所以在插入数据的时候，为了保证数据的有序性，只能在固定位置插入数据，
    - 因为数据都存在主键索引中，在数据位置发生修改的时候只需要修改索引即可，
    - 在查询的时候使用主键查询时只需要走一次索引查找，找到索引位置返回里面的数据即可，
    - 如果使用的是普通索引，则需要在普通索引的索引树中查询出主键，再回到主键索引树查询出数值
    - innoDB引擎把数据放在主键索引上，其他索引上保存的是主键的id，这种方式称之为索引组织表
  - Memory表的数据是按照写入顺序存放的，也就是说是无序的，主键索引中存放的是每个数据的位置，数据和索引各自单独存放，是分开的。主键索引的组织方式是hash表，数据的存放方式是数组
    - 插入数据的时候只需要找到一个空位，把数据的内存位置放入即可
    - 当数据位置发生了修改，那么就需要修改整个索引
    - 查找时并不区分是什么索引，通过这个表所有的索引，都可以定位到数据的位置，所以说所有索引的地位都是相同的
    - Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称之为堆组织表
- InnoDB 支持变长数据类型，不同记录的长度可能不同；
- Memory 不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。
- Memory 的锁
  - Memory 不支持行锁，只支持表锁，所以只要一张表上有更新操作，就会阻塞所有其他所有对该表的更新操作，不管有没有使用到索引
  - 锁的颗粒度太大，严重影响到了并发度
- Memory 的持久性问题
  - Memory 的所有数据都是存放在内存中的，读写的速度很快，但是这并不里有其持久化。
  - 如果数据库因为某种原因重启，内存表中的数据也就会被清空
  - 使用主备的时候，也会出现内存表突然被清空的情况，索引Memory 表并不适合作为普通数据表使用
- 但Memory 表的执行速度快而言，只有表级锁的并发度已经严重影响了它的速度
- 内存临时表，不管是系统自动创建的排序表还是用户自己创建的临时表，可以优先考虑使用Memory 引擎
  - 临时表都是独立的，只会被创建他的线程使用，不会被其他线程使用，没有并发度问题
  - 临时表使用完成后会被释放掉，数据被意外清空这个情况是不存在的
- Memory 表使用范围查找时，索引会失效，可以把hash索引切换为b_tree索引



