读写分离有哪些坑？

- 读写分离的主要目标就是分摊主库的压力。
- 客户端直连和带 proxy 的读写分离架构
  - 客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。
  - 带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。
  - 由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。

> 处理过期读的方案

- 强制走主库方案
  - 对于必须要拿到最新结果的请求，强制将其发到主库上。
  - 对于可以读到旧数据的请求，才将其发到从库上。
- sleep 方案；
  - 主库更新后，读从库之前先 sleep 一下。
- 判断主备无延迟方案；
  - 每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。
  - 对比位点确保主备无延迟
  - 对比 GTID 集合确保主备无延迟
- 配合 semi-sync 方案；
  - 事务提交的时候，主库把 binlog 发给从库；
  - 从库收到 binlog 以后，发回给主库一个 ack，表示收到了；
  - 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。
- 等主库位点方案;
- GTID 方案;