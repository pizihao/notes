什么时候会使用内部临时表？

- union  用于连接连个select语句，结果是取这两个子查询结果的并集。
- 如`(select 1000 as f) union (select id from t1 order by id desc limit 2);`,结果就是两个子查询的并集
- Using temporary 使用了临时表
- 如果 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，因此也就不需要临时表了。
- 在使用group by分组的时候也使用到了临时表
- 对于一个查询语句`select id%10 as m, count(*) as c from t1 group by m;`的过程是这样的：
  - 创建内存临时表，表里有两个字段 m 和 c，主键是 m；
  - 扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；
    - 如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);
    - 如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；
  - 遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。
- 如果并不需要对结果进行排序，可以在 SQL 语句末尾增加 order by null
- tmp_table_size 可以控制内存临时表的大小，默认16MB
- 这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB
- group by 优化方法 -- 索引
- 不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果查询的结果都是有序的那么计算 group by 的时候，就只需要从左到右，顺序扫描，依次累加。
- generated column 机制 可以实现列数据的关联更新，就是一个或几个列通过计算得出一个新的列，但是不会记录在表中，generated column 机制可以为这个新的列创建索引
- group by 优化方法 -- 直接排序
- 在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。
- mysql什么时候会使用临时表
  - 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
  - join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；
  - 如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如union 和 group by
- 总结
  - 如果对 group by 语句的结果没有排序要求，尽量在语句后面加 order by null；
  - 尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；
  - 如果 group by 需要统计的数据量不大，尽量只使用内存临时表；
  - 也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；
  - 如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。

