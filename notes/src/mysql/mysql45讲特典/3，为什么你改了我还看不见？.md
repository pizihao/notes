# 为什么你改了我还看不见？

**事务隔离**

- 简单来说事务就是要保证一组数据库的操作，要么全部成功，要么全部失败，在mysql中事务支持是在引擎层实现的
- 事务的特性 ACID（即原子性、一致性、隔离性、持久性）
- 脏读，不可重复读，幻读
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
- 事务隔离的实现，在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
- 不同时刻启动事务，会有不同的读视图（read-view）产生
- 因为不同事务的隔离级别可能会有不同，那么针对不同隔离级别的事务，访问最新记录的方式也是不同的
  - 对于使用**READ UNCOMMITTED** (读未提交)隔离级别的事务来说，会直接读取记录的最新版本。因为在该事务进行中他所进行的变更对于其他事务来说都是可见的
  - 对于使用**READ COMMITTED**和**REPEATABLE READ**隔离级别的事务来说，就需要通过ReadView追溯版本链，即undolog日志
  - 对于使用**SERIALIZABLE**隔离级别的事务来说，使用加锁的方式来访问记录。
- ReadView会包含当前所有的活跃的事务的事务id，所谓活跃事务是指已经开始了但是还没有commit的事务，把它们的事务id放到一个列表中，我们把这个列表命名为为**m_ids**。
- 这样在访问某条记录时，只需要按照下边的步骤判断该记录在版本链中的某个版本（trx_id）是否可见：
  - **trx_id** **<** **m_ids列表中最小的事务id** 
    表明生成该版本的事务在生成ReadView前已经提交，所以该版本**可以**被当前事务访问。
  - **trx_id** **>** **m_ids列表中最大的事务id** 生成ReadView的时候这个事务还没有生成
    表明生成该版本的事务在生成ReadView 后才生成，所以该版本**不可以**被当前事务访问。
  - **m_ids列表中最小的事务id** **<** **trx_id** **<** **m_ids列表中最大的事务id**
    （1）trx_id在m_ids中：说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问。
    （2）trx_id不在m_ids中：说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。
- 对于**READ COMMITTED**和**REPEATABLE READ**两个隔离级别的事务来说生成readview的时机是不同的
- READ COMMITTED 读已提交，对于这个事务中的所有查询语句。每一条sql都会生成一个readview，这个readview会包含当前活跃的事务id，所以对于这种隔离级别的事务每次读到的都是当前时间点下其他事务已经提交后的信息
- REPEATABLE READ 重复读，它在执行第一条select的时候会生成一个readview，当再执行下一条查询语句的时候，直接复用这个时候的readview，不再创建，所以这个readview存放的还是执行第一条select的时候的那些事务id，读出来的是重复的
- 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的
- MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程，这样子可以使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。